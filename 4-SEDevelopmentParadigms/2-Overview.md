# Overview

## Content

### Software Cost Estimation slide 1 [3:00]

### Software Cost Estimation slide 2 [7:00]

### Objectives (cost estimation of software) [7:25]

COCOMO 2 (improved)

- constructive cost model

- algorithmic cost estimation model

- best we have

- not accurate

- good estimate

- starting point

### Fundamental estimation questions [11:29]

to complete activity:

- effort required

- calendar time

- total cost

Project estimation and scheduling

### Software cost components

Costs of:

- Hardware, software

- Travel, training

- Effort (main factor)

  * salaries of engineers involved in the project

  * social and insurance costs

- Effort costs (incl. overheads)

  * building, heating, lighting

  * networking, communications

  * shared facilities

### Costing and pricing  [15:29]

- Estimates to discover cost, to developer of producing the software

- not a simple relationship between development cost 

  * and price charged to customer

- Broader cost to organisation

### Software pricing factors [16:28]

Level 1: Factor, Level 2: Description

- Market opportunity

  * Reasoning for lower prices:

    * move into a new segment of market

    * early low profit project may allow more profit later

    * experience allowing new products to be developed

- Cost estimate uncertainty

  * If organisation unsure of cost estimate:

    * may increase price by contingency over normal price

- Contractual terms

  * customer willing to developer retain ownership of source code and reuse in other projects.

  * price charged may be less than if software source code handed over to the customer.

- Requirements volatility

  * if requirements likely to change,

    * organisation may lower price to win a contract.

  * After contract awarded, 

    * high prices may be charged for changes to requirements.

- Financial health

  * Developers in financial difficulty may 

    * lower price to gain contract

  * Better to make a small profit

    * or break even than

    * to go out of business

### Programmer productivity [19:37]

- measure: rate individual engineers in software development produce software

  * and associated documentation

- Not quality-oriented

  * although quality assurance is a factor

  * in productivity assessment

- want to measure useful functionality per unit time

### Productivity measures [22:36]

- Size related measures based on output from software process.

  * may be lines of delivered source code,

    * object code instructions

- Function-related measures:

  * based on an estimate of:

    * functionality of the delivered software.

  * Function-points:
    * best known of this type of measure

### Cobol [22:27]

100,000 lines of COBOL

for every programmer who ever lived.

Start in COBOL with lots of standard code:

  * to facilitate the parser going through and finding each section

1. keyword:

identification division

2. declare global variables

Note: Compiler marks every error in file, not just the first.

[23:57]

There are programs where you write stuff at the beginning

that does not produce anything.

Does that code count the same as 

code actually doing work?

No, but measured the same way.





## References

[* space space * space space * | multiple indent level bullet point lists in markdown | new relic](https://docs.newrelic.com/docs/style-guide/structure/styleguide-markup-indentation/)
